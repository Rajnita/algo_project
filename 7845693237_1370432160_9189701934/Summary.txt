SUMMARY

####################################### Team Members ##########################################

The following (<Name> - <Student Id>) are the members of the team:

Rajnita Leichombam - 1370432160
Vaishnav Sai Krishna Addagulla - 7845693237
Karishma - 9189701934


##################################### Tasks Ownership ##########################################

Task 1:  Create Github Repo, Preparing Skeleton and Structure of the Project - Rajnita Leichombam
Task 2:  File Handling Implementation- Reading & Writing to Files - Rajnita Leichombam 
Task 3:  Generation of Input Strings - Vaishnav Sai Krishna Addagulla
Task 4:  Basic Algorithm Implementation (Finding min cost using 2D memoization table) - Rajnita Leichombam
Task 5:  Basic Algorithm (Backtracking Logic to generate sequences from memoization Table) - Vaishnav Sai Krishna Addagulla
Task 6:  Efficient Algorithm Implementation(Finding min cost and generation of outputsequences) - Karishma Pherwani
Task 7:  Preparation of Summary.txt - Rajnita Leichombam, Karishma Pherwani
Task 8:  Report - Summary.txt Review - Karishma Pherwani, Vaishnav Sai Krishna Addagulla
Task 9:  Code Review of the project - Karishma Pherwani, Vaishnav Sai Krishna Addagulla, Rajnita
Task 10: Test Plan and Cases preparation (listing test cases, edge cases, etc) - Vaishnav Sai Krishna Addagulla
Task 11: Plotting of graphs using MS Excel - Vaishnav Sai Krishna Addagulla
Task 12: Collection of data points for plotting - Rajnita Leichombam
Task 13: Adding Shell Scripts - Rajnita Leichombam
Task 14: Time and memory calculation in Java - Rajnita Leichombam
Task 15: Reading and posting questions using Communication channels (Piazza) - Vaishnav Sai Krishna Addagulla


###################################### INSIGHTS & OBSERVATIONS ##################################

BASIC ALGORITHM (Sequence Alignment)

Recurrence relation used: 
The minimum alignment costs satisfy the following recurrence for i ≥ 1 and j ≥ 1:
OPT(i,j)=min[αxiyj +OPT(i−1,j−1),δ+OPT(i−1,j),δ+OPT(i,j−1)].

For'm' as the length of the first generated input string and 'n' as the length of the second generated input String we have 
time complexity as O(mn) ,
space complxity as O(mn) as we have a 2-D array (memoization table).
To reconstruct the solution, we trace back from the corner of the memoization table i.e. memoization[m][n]. Depending on how the cell is filled i.e. which of the three values as specified in the above recurrence relation is used.


Observation 1. The length of a shortest path that uses (i, j) is f (i, j) + g(i, j).
Observation 2. let q be an index that minimizes f (q, n/2) + g(q, n/2). Then, there exists a shortest path from (0, 0) to (m, n) that uses (q, n/2).

EFFICIENT ALGORITHM (Using Divide and Conquer)
Idea: a divide-and-conquer algorithm to compute half alignments
For the efficient algorithm we need O(N) for storing the computation arrays or the global list and O(N+M) to store the optimal alignment.

Given 2 strings X and Y, we can, in linear space and O(nm) time, we compute the cost of aligning...
• every prefix of X with Y
• X with every prefix of Y
• a particular prefix of X with every prefix of Y
• a particular suffix of X with every suffix of Y

Define:
• AllYPrefixCosts(x, i, y) = returns an array of the scores of optimal alignments between x[1..i] and all prefixes of Y.
• AllYSuffixCosts(x, i, y) = returns an array of the scores of optimal alignments between x[i..n] and all suffixes of y


def Align(x, y):
n := |x|; m := |y|
if n or m ≤ 2: use standard alignment and return alignment

YPrefix := AllYPrefixCosts(x, n/2, y)
YSuffix := AllYSuffixCosts(x, n/2+1, y)

for q := 0..m:
cost = YPrefix[q] + YSuffix[q+1]
if cost < best: bestq = q; best = cost

midCharCost = YPrefix[1][bestq];
gapCharCost = YPrefix[0][bestq];

if midCharCost == (gapCharCost + penalty)
    Align(x[1..n/2], y[1..bestq+1])
    Align(x[n/2+1..n], y[bestq+1..m])
    return alignment
else
    Align(x[1..n/2], y[1..bestq])
    Align(x[n/2+1..n], y[bestq+1..m])
    return alignment


COMPARISONS BETWEEN THE TWO ALGORITHMS

 In the basic algorithm, we can see that OPT(i,j) relies only on rows i,i-1 and columns j,j-1. We only need to track the current row and previous row in memory. This will allow us to obtain value of OPT(i,j), but not the path. 
 So Hirschberg devised an algorithm using divide and conquer and dynamic programming tto solve the issue.

 Building up the 2-D m-by-n array (memoization table) of optimal solutions to subproblems, clearly it is equivalent to constructing a graph Gxy with mn nodes laid out in a grid and looking for the cheapest path between opposite corners.

 Let f (i, j) to denote the length of the shortest path from (0, 0) to (i, j) in the graph Gxy . As we showed in the initial basic sequence alignment algorithm, f(i,j) has the same value as OPT(i, j).) Now let g(i, j) to be the length of the shortest path from (i, j) to (m, n) in Gxy.The answer we want is g(0,0),
 In the space efficient algorithm, we divide Gxy along its centre column and compute f(i,n/2) and g(i,n/2) for each i

Comments on why the efficient and basic versions have different memory and time plots.

Using (6.20) and our space-efficient algorithms to compute the value of the optimal alignment, we will proceed as follows. We divide GXY along its center column and compute the value of f (i, n/2) and g(i, n/2) for each value of i, using our two space-efficient algorithms. We can then determine the minimum value of f (i, n/2) + g(i, n/2), and conclude via (6.20) that there is a shortest corner-to-corner path passing through the node (i, n/2). Given this, we can search for the shortest path recursively in the portion of GXY between (0, 0) and (i, n/2) and in the portion between (i, n/2) and (m, n). The crucial point is that we apply these recursive calls sequentially and reuse the working space from one call to the next. Thus, since we only work on one recursive call at a time, the total space usage is O(m + n). The key question we have to resolve is whether the running time of this algorithm remains O(mn).

Notice that σ(i, j) only relies on rows i and i − 1. So, as we run the algorithm we only need to keep the
current row and the previous row in memory. This will allow us to obtain the value of σ(m, n), however, we
have lost our information to be able to backtrack and return the path.
 Memory and Time:
 To put this in relatable terms, if we are comparing two 100,000 long strings, our DP
 array will be 10 GB large. This may be too large to fit in the main memory of some computers.







Analysis of plotted graphs




###################################### PROJECT FILES DESCRIPTION & OTHER IMPORTANT NOTES #######################











